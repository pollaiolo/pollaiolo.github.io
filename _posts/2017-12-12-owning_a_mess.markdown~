---
layout: post
title:  "The cost of owning a mess"
subtitle: "A long post about quality"
date:   2017-12-12 23:34:01
comments: true
categories: [essentials]
published: true
---
## Recipe
<i class="fa fa-check-square" style="color:#828282"></i> **Patience to read** \\
<i class="fa fa-github" style="color:#828282"></i> **[Instant Lottery](https://github.com/pollaiolo/InstantLottery)**

## Foreword
Recently, I had a lecture at the University of Rome3 where I spoke about *Quality through Software Process*. When I started working on this talk I thought that I wouldn't have had the need to present any practical example since the topic was really abstract: *Quality*. I realized, very soon, that nothing could have explained this concept better than **code**. Because the code is the tool we use to give quality to our projects and nothing is more concise and clear than this.\\
I ended up building a fullstack application that you can see in my repository. During the talk I did a couple of live coding sessions where I explained the mistakes I intentionally put in a first version of the app. Then I refactored and committed the *correct* version during the talk. You can take a look at the bad design choices and their solutions by navigating the `GIT` history of the repository.\\
This post will not be about the web application and neither will be a transcription of the talk. What I would like to underline here is how *quality* can be achieved and why we should strive to keep it as high as possible.

## Quality Process
Writing code with other people, for its nature, tends to chaos. A methodological approach to software development is needed to avoid to fight with colleagues and with clients eventually. This method is the *Software Process*. There are tons of definition on the web but I'd like to define it more pragmatically: a sequence of steps through which every component has to pass. Every member of the team has to agree on the defined process and follow it. In my experience I've always worked on **SCRUM** based processes where each component is *defined*, *developed*, *tested* and then *reviewed* before being considered completed. If a step fails then the component go back to the first step. This chain of steps is the internal core of the process which guarantee the correctness of each component. 

## @author
The JavaDoc keywork `@author` says what we are: authors. Characteristic of the authors is that they have readers; someone will read the code we write and will judge our work. I would like that who will read my code will say *"That's brilliant, let's reuse this component!"* and not *"WTF dude!"*.\\
As an author, I always sign my work (every `Java` class I write) and I think it's a good way to obey me to write clean and concise code. Whenever I feel I wouldn't sign a class that means I have to refactor it because something is not good as it should be.

## Comments
Before even consider *Design Patterns*, in my opinion, we should think about code *expressiveness*. Code should be easy to read and I should be able to read the code as I read a story without losing myself investigating on which method does what. Reading a method shuold reveal its purpose without having to navigate infinite classes; everything should be *obvious*. Often, I realize to be little expressive when I feel the need to put a comment inside a function; I have to explain something that should be obvious.\\
Disclaimer: comments are needed to explain *non-obvious* code choices and they should be present on every `public` function.



 
